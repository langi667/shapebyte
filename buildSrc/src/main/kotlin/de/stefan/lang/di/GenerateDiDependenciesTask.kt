package de.stefan.lang.di

import java.io.File
import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.provider.ListProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.Input
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction

abstract class GenerateDiDependenciesTask : DefaultTask() {

    @get:Input
    abstract val packageName: Property<String>

    @get:Input
    abstract val className: Property<String>

    @get:Input
    abstract val moduleDependencies: ListProperty<ModuleDependency>

    @get:Input
    abstract val rootAggregator: Property<Boolean>

    init {
        rootAggregator.convention(false)
    }

    @get:OutputDirectory
    abstract val outputDir: DirectoryProperty

    @TaskAction
    fun generate() {
        val modules = moduleDependencies.get()
        val outputDirectory = outputDir.get().asFile
        if (!outputDirectory.exists()) {
            outputDirectory.mkdirs()
        }
        val outputFile = File(outputDirectory, "${className.get()}.kt")
        outputFile.writeText(renderFile(modules))
    }

    private fun renderFile(modules: List<ModuleDependency>): String {
        val pkg = packageName.get()
        val klass = className.get()
        val skipDelegations = false
        val moduleImports = modules.map { it.moduleClass }.toSet().sorted()
        val contractImports = modules.map { it.contractClass }.toSet().sorted()
        val modulesList = modules.joinToString(separator = ",\n") {
            "        ${simpleName(it.moduleClass)}"
        }
        val delegations = if (skipDelegations) emptyList() else modules.map {
            "${simpleName(it.contractClass)} by ${simpleName(it.moduleClass)}"
        }
        val implementsClause = if (delegations.isEmpty()) {
            ""
        } else {
            " :\n    " + delegations.joinToString(",\n    ")
        }
        return buildString {
            appendLine("// Generated by GenerateDiDependenciesTask. Do not modify manually.")
            appendLine("package $pkg")
            appendLine()
            appendLine("import de.stefan.lang.core.di.RootModule")
            appendLine("import de.stefan.lang.core.di.ModuleBindings")
            appendLine("import org.koin.dsl.ModuleDeclaration")
            moduleImports.forEach { appendLine("import $it") }
            contractImports.forEach { appendLine("import $it") }
            appendLine()
            appendLine("internal object $klass$implementsClause {")
            appendLine("    public val modules: List<RootModule> = listOf(")
            if (modules.isNotEmpty()) {
                appendLine(modulesList)
            }
            appendLine("    )")
            appendLine("}")
            appendLine()
            appendLine("public abstract class Module : RootModule {")
            appendLine("    internal constructor(")
            appendLine("        globalBindings: ModuleDeclaration = {},")
            appendLine("        productionBindings: ModuleDeclaration = {},")
            appendLine("        testBindings: ModuleDeclaration = {},")
            appendLine("    ) : super(")
            appendLine("        globalBindings = globalBindings,")
            appendLine("        productionBindings = productionBindings,")
            appendLine("        testBindings = testBindings,")
            appendLine("        dependencies = Dependencies.modules,")
            appendLine("    )")
            appendLine()
            appendLine()
            appendLine("    init { /* dependencies wired automatically */ }")
            appendLine("}")
        }
    }

    private fun simpleName(fqcn: String): String = fqcn.substringAfterLast('.')
}
